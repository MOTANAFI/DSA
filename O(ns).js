//O(n) - Linear Time Complexity
// const studentsDatabase = ["mohamed", "erick", "John", "michael"];
// const findStudent = (allStudents, studentName) => {
//   for (let i = 0; i < allStudents.length; i++) {
//     if (allStudents[i] === studentName) {
//       console.log(`Fount ${studentName}`);
//       return
//     }
//   }
// };

// findStudent(studentsDatabase, "erick");

// const groceries = ['milk', 'bread', 'eggs', 'flour', 'cheese', 'sugar'];

// const searchForItem = item => {
//     for(let i=0; i<groceries.length; i++){
//         if(groceries[i] === item){console.log(`Found ${item}`);
//             return;
//     }
// }

// for(let j=0; j<groceries.length; j++){
//     if(groceries[j] == item ) {
//         console.log(`Found ${item}`);
//         return
//     }
// }
// // n + n = 2n => O(n)
// }

// searchForItem('eggs');

// O(1), or constant time complexity, means that the time taken to execute an operation is the same regardless of the size of the input.

// const numbers = [1,2,3,4,5];

// const getElement = (arr, index) => arr[index];

// console.log(getElement(numbers, 3)); // O(1) - Constant Time Complexity`

// O(n^2) - Quadratic Time Complexity
// indicates that algorithm's execution grows quadratically with the input size data (represented by n)

// function findPairs(arr) {
//   for (let i = 0; i < arr.length; i++) {
//     for (let j = i + 1; j < arr.length; j++) {
//       console.log(`pair: ${arr[i]}, ${arr[j]}`);
//     }
//   }

//   //O(n)
//   for (let q = 0; q < 5; q++) {
//     console.log("----------", q);
//   }
// }

// const numbers = [1, 2, 3, 4, 5];

// findPairs(numbers); // O(n^2) - Quadratic Time Complexity

// O(log n) - Logarithmic Time Complexity 
// refers to an algorithm's runtime that grows logarithmically
// with the size of the input(reprensented by n). in simple terms,
// as the input size increases, the time it takes for the algorithm
// to run increases slowly. 


